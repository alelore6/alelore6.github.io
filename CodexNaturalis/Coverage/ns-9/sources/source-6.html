


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Game</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">it.polimi.ingsw.Model</a>
</div>

<h1>Coverage Summary for Class: Game (it.polimi.ingsw.Model)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Game</td>
<td class="coverageStat">
  <span class="percent">
    87%
  </span>
  <span class="absValue">
    (20/23)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    57,4%
  </span>
  <span class="absValue">
    (109/190)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71,2%
  </span>
  <span class="absValue">
    (178/250)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Game$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    63,3%
  </span>
  <span class="absValue">
    (19/30)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85,7%
  </span>
  <span class="absValue">
    (42/49)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1711051420</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1711051420$auxiliary$3LSevzn8</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1711051420$auxiliary$5IbH9k6a</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1711051420$auxiliary$BbYPftTj</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1711051420$auxiliary$BekEoGPX</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1711051420$auxiliary$eMvuhrh0</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1711051420$auxiliary$FwWoLuts</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1711051420$auxiliary$HEftjbWl</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1711051420$auxiliary$M2JQqQfE</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1711051420$auxiliary$Pflp4z54</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1711051420$auxiliary$R24RZg1z</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1711051420$auxiliary$sdXLy5A6</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1711051420$auxiliary$SoeH2IEX</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1711051420$auxiliary$up4WbMCB</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1711051420$auxiliary$VnVjsQZn</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1711051420$auxiliary$VRLt8HZt</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1711051420$auxiliary$XO8iL4SC</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1711051420$auxiliary$zBkJJlDp</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1711051420$auxiliary$ZLE0q1PQ</td>
  </tr>
  <tr>
    <td class="name">Game$MockitoMock$1711051420$auxiliary$zO6eaRqB</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    88%
  </span>
  <span class="absValue">
    (22/25)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    58,2%
  </span>
  <span class="absValue">
    (128/220)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    73,6%
  </span>
  <span class="absValue">
    (220/299)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package it.polimi.ingsw.Model;
&nbsp;
&nbsp;import it.polimi.ingsw.Events.*;
&nbsp;import it.polimi.ingsw.Exceptions.HandFullException;
&nbsp;import it.polimi.ingsw.Exceptions.WrongPlayException;
&nbsp;import it.polimi.ingsw.Exceptions.isEmptyException;
&nbsp;import it.polimi.ingsw.Listeners.ModelViewListener;
&nbsp;import it.polimi.ingsw.ModelView.GameView;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.HashMap;
&nbsp;
&nbsp;/**
&nbsp; * Class that manages the game life cycle, from the start to end.
&nbsp; */
&nbsp;public class Game{
&nbsp;    /**
&nbsp;     * attribute representing if threads of this class are running.
&nbsp;     */
<b class="fc">&nbsp;    private volatile boolean running = true;</b>
&nbsp;    /**
&nbsp;     * attribute that indicates if the turn of a disconnected player has been skipped.
&nbsp;     */
<b class="fc">&nbsp;    private volatile boolean isTurnSkipped = false;</b>
&nbsp;    /**
&nbsp;     * number of players in the current game
&nbsp;     */
&nbsp;    private volatile int numPlayers;
&nbsp;    /**
&nbsp;     * String that represents the turn order.
&nbsp;     */
<b class="fc">&nbsp;    private String turnOrder = &quot;&quot;;</b>
&nbsp;    /**
&nbsp;     * attribute that keeps count of the number of turns completed since the beginning
&nbsp;     */
&nbsp;    private int turnCounter;
&nbsp;    /**
&nbsp;     * attribute representing the seconds to wait for another player to continue the game
&nbsp;     */
&nbsp;    public static final int timeoutOnePlayer = 60;
&nbsp;    /**
&nbsp;     * boolean that states if the game is either finished or still in act
&nbsp;     */
&nbsp;    public volatile boolean isFinished;
&nbsp;    /**
&nbsp;     * attribute that keeps count of remaining turns when the ending stage of the game is triggered
&nbsp;     */
&nbsp;    private int remainingTurns;
&nbsp;    /**
&nbsp;     * integer representing the current player position in the array of players
&nbsp;     */
&nbsp;    private int curPlayerPosition;
&nbsp;
&nbsp;    /**
&nbsp;     * Setter for curPlayerPosition.
&nbsp;     * @param curPlayerPosition index of the current player in the players array
&nbsp;     */
&nbsp;    public void setCurPlayerPosition(int curPlayerPosition) {
<b class="fc">&nbsp;        this.curPlayerPosition = curPlayerPosition;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The starting cards deck
&nbsp;     */
&nbsp;    private final StartingDeck StartingDeck;
&nbsp;    /**
&nbsp;     * The array containing the players of this current game
&nbsp;     */
&nbsp;    public ArrayList&lt;Player&gt; players;
&nbsp;    /**
&nbsp;     * The tablecenter attribute containing the two decks (resource and gold) and the cards on it (2 res, 2 gold, 2 obj)
&nbsp;     */
&nbsp;    public TableCenter tablecenter;
&nbsp;
&nbsp;    /**
&nbsp;     * List of players&#39; listeners.
&nbsp;     */
&nbsp;    private ArrayList&lt;ModelViewListener&gt; mvListeners;
&nbsp;
&nbsp;    /**
&nbsp;     * List of available tokens, in the sense that they&#39;re not chosen yet.
&nbsp;     */
&nbsp;    final ArrayList&lt;TokenColor&gt; availableTokens;
&nbsp;    /**
&nbsp;     * Attribute that counts how many players have completed a specific action.
&nbsp;     * Usually, the server waits for all the players using this.
&nbsp;     */
<b class="fc">&nbsp;    public int waitNumClient = 0;</b>
&nbsp;    /**
&nbsp;     * number representing the turn phase: 0: start turn, 1: play done, 2: draw done
&nbsp;     */
<b class="fc">&nbsp;    public int turnPhase=0;</b>
&nbsp;    /**
&nbsp;     * boolean representing whether the game has started
&nbsp;     */
<b class="fc">&nbsp;    public boolean isStarted = false;</b>
&nbsp;    /**
&nbsp;     * boolean representing whether end game has been triggered or not
&nbsp;     */
<b class="fc">&nbsp;    public boolean isTriggered = false;</b>
&nbsp;    /**
&nbsp;     * lock for synchronization with the controller
&nbsp;     */
<b class="fc">&nbsp;    public final Object lock = new Object();</b>
&nbsp;    /**
&nbsp;     * Lock for waiting a certain amount of time when only one player is remaining.
&nbsp;     */
<b class="fc">&nbsp;    public final Object OPLLock = new Object();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Constructor: initializes the Game class, creating the players, turnCounter, remainingTurns, isFinished and
&nbsp;     * creating the startingDeck instance as well.
&nbsp;     *
&nbsp;     * @param numPlayers number of players in the current game
&nbsp;     * @param nicknames  array of nicknames passed by user, used to create the players classes
&nbsp;     * @param mvListeners the model-view listeners of the players
&nbsp;     */
<b class="fc">&nbsp;    public Game(int numPlayers, String[] nicknames, ArrayList&lt;ModelViewListener&gt; mvListeners) {</b>
<b class="fc">&nbsp;        this.mvListeners =  mvListeners;</b>
<b class="fc">&nbsp;        this.numPlayers = numPlayers;</b>
<b class="fc">&nbsp;        this.turnCounter = 0;</b>
<b class="fc">&nbsp;        this.isFinished = false;</b>
<b class="fc">&nbsp;        this.remainingTurns = -1;</b>
<b class="fc">&nbsp;        this.curPlayerPosition = -1;</b>
<b class="fc">&nbsp;        players = new ArrayList&lt;&gt;(numPlayers);</b>
<b class="fc">&nbsp;        for (int i=0;i&lt;numPlayers;i++ ){</b>
<b class="fc">&nbsp;            players.add(new Player(nicknames[i], this));</b>
&nbsp;        }
<b class="fc">&nbsp;        tablecenter = new TableCenter(new ResourceDeck(), new GoldDeck(), new ObjectiveDeck(), this);</b>
<b class="fc">&nbsp;        StartingDeck = new StartingDeck();</b>
<b class="fc">&nbsp;        availableTokens = new ArrayList&lt;TokenColor&gt;();</b>
&nbsp;        //all tokens available
<b class="fc">&nbsp;        for(TokenColor c: TokenColor.values()){</b>
<b class="fc">&nbsp;            availableTokens.add(c);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Getter for tablecenter instance
&nbsp;     * @return Tablecenter instance
&nbsp;     */
<b class="fc">&nbsp;    public TableCenter getTablecenter() {return tablecenter;}</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Getter for the list of players
&nbsp;     *
&nbsp;     * @return the list of players
&nbsp;     */
<b class="fc">&nbsp;    public ArrayList&lt;Player&gt; getPlayers() {return players;}</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Getter for number of players
&nbsp;     * @return number of players
&nbsp;     */
<b class="fc">&nbsp;    public int getNumPlayers() {return numPlayers;}</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Getter for remainingTurns attribute
&nbsp;     * @return number of remaining turns after the triggering of the end game phase, else -1
&nbsp;     */
<b class="nc">&nbsp;    public int getRemainingTurns() {return remainingTurns;}</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Getter for the current player&#39;s nickname
&nbsp;     * @return the current player&#39;s nickname
&nbsp;     */
&nbsp;    public String getCurrentPlayerNickname(){
<b class="pc">&nbsp;        return curPlayerPosition != -1 ? players.get(curPlayerPosition).getNickname() : null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Getter for the current player index in the list of players
&nbsp;     * @return the index of the current player in the list of players
&nbsp;     */
&nbsp;    public int getCurPlayerPosition() {
<b class="fc">&nbsp;        return curPlayerPosition;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * After the game has been initialized, the method starts it, laying all the cards on the table
&nbsp;     * and filling each player&#39;s hand, making them also choose the objective card between the two given.
&nbsp;     * It also randomly chooses the first player and orders the other ones from left to right.
&nbsp;     * In the end, it loops checking the number of remaining players.
&nbsp;     * @throws RuntimeException if the decks are empty (should not happen at the beginning)
&nbsp;     */
&nbsp;    public void startGame() throws RuntimeException{
&nbsp;
<b class="fc">&nbsp;        for(int i = 0; i &lt; 4; i++){  //Riempio le carte a terra per la prima volta dai deck</b>
<b class="fc">&nbsp;            if(i &lt; 2){</b>
&nbsp;                try {
<b class="fc">&nbsp;                    tablecenter.getCenterCards()[i] = tablecenter.getResDeck().draw();</b>
<b class="nc">&nbsp;                } catch (isEmptyException e) {</b>
<b class="nc">&nbsp;                    throw new RuntimeException(e);</b>
&nbsp;                }
<b class="fc">&nbsp;                tablecenter.getObjCards()[i] = tablecenter.getObjDeck().draw();</b>
&nbsp;            }
<b class="fc">&nbsp;            if(i &gt;= 2){</b>
&nbsp;                try {
<b class="fc">&nbsp;                    tablecenter.getCenterCards()[i] = tablecenter.getGoldDeck().draw();</b>
<b class="nc">&nbsp;                } catch (isEmptyException e) {</b>
<b class="nc">&nbsp;                    throw new RuntimeException(e);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        //in un thread perchè si deve aspettare la sincronizzazione dal controller
<b class="fc">&nbsp;        new Thread(){</b>
&nbsp;            @Override
&nbsp;            public void run() {
<b class="fc">&nbsp;                int pos = 0;</b>
<b class="fc">&nbsp;                for (Player p : players) {</b>
<b class="fc">&nbsp;                    SetTokenColorRequest setTokenColor = new SetTokenColorRequest(p.getNickname(), availableTokens);</b>
<b class="fc">&nbsp;                    getMVListenerByNickname(p.getNickname()).addEvent(setTokenColor);</b>
&nbsp;
&nbsp;                    //every player gets to choose between 2 objective cards
<b class="fc">&nbsp;                    ChooseObjectiveRequest chooseObjective = null;</b>
<b class="fc">&nbsp;                    if (tablecenter.getObjDeck().getNCards() != 0) {</b>
<b class="fc">&nbsp;                        chooseObjective = new ChooseObjectiveRequest(tablecenter.getObjDeck().draw(), tablecenter.getObjDeck().draw(), p.getNickname());</b>
&nbsp;                    }
<b class="fc">&nbsp;                    getMVListenerByNickname(p.getNickname()).addEvent(chooseObjective);</b>
&nbsp;
&nbsp;                    //every place gets to place his starting card
<b class="fc">&nbsp;                    StartingCard startingCard = null;</b>
<b class="fc">&nbsp;                    if (StartingDeck.getNCards() != 0) {</b>
&nbsp;                        try {
<b class="fc">&nbsp;                            startingCard = StartingDeck.draw();</b>
<b class="fc">&nbsp;                            getMVListenerByNickname(p.getNickname()).addEvent(new PlaceStartingCard(startingCard, p.getNickname()));</b>
<b class="nc">&nbsp;                        } catch (isEmptyException e) {</b>
&nbsp;                            //shouldn&#39;t happen
<b class="nc">&nbsp;                            throw new RuntimeException(e);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    try {
<b class="fc">&nbsp;                        p.getHand().DrawFromDeck(tablecenter.getResDeck());</b>
<b class="fc">&nbsp;                        p.getHand().DrawFromDeck(tablecenter.getResDeck());   //RIEMPIO LA MANO DEL GIOCATORE 2 carte res e 1 gold</b>
<b class="fc">&nbsp;                        p.getHand().DrawFromDeck(tablecenter.getGoldDeck());</b>
<b class="fc">&nbsp;                    } catch (isEmptyException | HandFullException e) {</b>
&nbsp;                        //should not happen
&nbsp;                    }
&nbsp;
&nbsp;
<b class="fc">&nbsp;                    pos++;</b>
&nbsp;                }
&nbsp;
&nbsp;                while(true) {
&nbsp;                    //wait for everyone to complete the start
<b class="fc">&nbsp;                    synchronized (lock){</b>
<b class="pc">&nbsp;                        if (waitNumClient == getActivePlayers()) break;</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                //dopo che ho inizializzato tutti
<b class="fc">&nbsp;                String[] order= new String[numPlayers];</b>
&nbsp;                //DECISIONE RANDOMICA PRIMO GIOCATORE, genero int da 0 a numplayer
<b class="fc">&nbsp;                int firstPlayerPos = (int) (Math.random()*numPlayers);</b>
&nbsp;
<b class="fc">&nbsp;                int j = firstPlayerPos;</b>
<b class="fc">&nbsp;                for(int i = 0; i &lt; numPlayers; i++){</b>
&nbsp;                    //loop per settare la posizione in senso orario (da sinistra a destra) di tutti i player
<b class="pc">&nbsp;                    if (j &gt;= numPlayers) {j = 0;}</b>
<b class="fc">&nbsp;                    players.get(j).position = i;</b>
<b class="fc">&nbsp;                    order[i]= players.get(j).getNickname();</b>
<b class="fc">&nbsp;                    j++;</b>
&nbsp;                }
&nbsp;
&nbsp;
<b class="fc">&nbsp;                for (int i=0; i&lt;order.length;i++) {</b>
<b class="fc">&nbsp;                    int x=i+1;</b>
<b class="fc">&nbsp;                    turnOrder = turnOrder.concat(&quot;\n\t&quot;+ x + &quot;. &quot; + order[i] + &quot; &quot;);</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                isStarted = true;</b>
&nbsp;
<b class="fc">&nbsp;                turnPhase=-1;</b>
&nbsp;                //notify all players on turn order
<b class="fc">&nbsp;                TurnOrder event = new TurnOrder(&quot;every one&quot;, turnOrder, Game.this.clone());</b>
<b class="fc">&nbsp;                for(ModelViewListener modelViewListener : mvListeners) modelViewListener.addEvent(event);</b>
&nbsp;                //devo trovare il giocatore precedente al primo!
&nbsp;                //perchè next player fa l&#39;avanzamento
<b class="fc">&nbsp;                int p= firstPlayerPos-1;</b>
<b class="pc">&nbsp;                if (p&lt;0) p=numPlayers-1;</b>
<b class="fc">&nbsp;                nextPlayer(players.get(p));</b>
&nbsp;                //INIZIO IL GIOCO CHIAMANDO IL METODO NEXTPLAYER SUL PRIMO GIOCATORE
&nbsp;
&nbsp;                // Loop that checks if the active players are less than 2.
<b class="pc">&nbsp;                while(running){</b>
<b class="pc">&nbsp;                    if     (getActivePlayers() == 1) OPLProcedure(true);</b>
<b class="pc">&nbsp;                    else if(getActivePlayers() == 0){</b>
&nbsp;                        // If there&#39;s no player left.
<b class="nc">&nbsp;                        System.exit(2);</b>
&nbsp;                    }
<b class="pc">&nbsp;                    if(isTurnSkipped){</b>
<b class="nc">&nbsp;                        isTurnSkipped = false;</b>
<b class="nc">&nbsp;                        if(getRemainingTurns() == 0)        checkWinner();</b>
<b class="nc">&nbsp;                        else if(getCurrentPlayerNickname() != null) nextPlayer(players.get(getCurPlayerPosition()));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;        }.start();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * sets the parameter remainingTurns accordingly, displays a message on the user screen stating which
&nbsp;     * occasion triggered the endgame status notifying the Controller as well.
&nbsp;     * @param occasion states the case that triggered the endgame process such as:
&nbsp;     * &quot;player X has reached 20 points&quot; or
&nbsp;     * &quot;both decks are empty&quot;
&nbsp;     */
&nbsp;    public void endGame(int occasion){
<b class="pc">&nbsp;        switch(occasion){</b>
&nbsp;            // a player reached 20 points
&nbsp;            case 0,1,2,3:
<b class="fc">&nbsp;                isTriggered = true;</b>
&nbsp;                // a full round plus the turns remaining of this one
<b class="fc">&nbsp;                remainingTurns = numPlayers + (numPlayers-(players.get(curPlayerPosition).position + 1)); //calcolo turni rimanenti</b>
<b class="fc">&nbsp;                String nickname = players.get(curPlayerPosition).getNickname();</b>
&nbsp;                //notify all players
<b class="fc">&nbsp;                for(int i=0;i&lt;numPlayers;i++){</b>
<b class="fc">&nbsp;                    EndGameTriggered event=new EndGameTriggered(nickname + &quot; has reached 20 points. Starting endgame process&quot;, players.get(i).getNickname(),clone());</b>
<b class="pc">&nbsp;                    if(!players.get(i).isDisconnected) getMVListenerByNickname(players.get(i).getNickname()).addEvent(event);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            //both decks are found empty simultaneously
&nbsp;            case 4:
<b class="fc">&nbsp;                isTriggered = true;</b>
<b class="fc">&nbsp;                tablecenter.getGoldDeck().AckEmpty=true;</b>
<b class="fc">&nbsp;                tablecenter.getResDeck().AckEmpty=true;</b>
<b class="fc">&nbsp;                remainingTurns = numPlayers + (numPlayers-curPlayerPosition); //calcolo turni rimanenti</b>
&nbsp;                //notify all players
<b class="fc">&nbsp;                for(int i=0;i&lt;numPlayers;i++){</b>
<b class="fc">&nbsp;                    EndGameTriggered event=new EndGameTriggered(&quot;Zero cards left! Starting endgame process&quot;, players.get(i).getNickname(),clone());</b>
<b class="fc">&nbsp;                    getMVListenerByNickname(players.get(i).getNickname()).addEvent(event);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            //gold deck is found empty
&nbsp;            case 5:
&nbsp;                // if I already had this information do nothing
<b class="pc">&nbsp;                if(tablecenter.getGoldDeck().AckEmpty)</b>
&nbsp;                    break;
&nbsp;                //else set AckEmpty to true
<b class="fc">&nbsp;                tablecenter.getGoldDeck().AckEmpty=true;</b>
&nbsp;                //if resource deck is known empty
<b class="fc">&nbsp;                if(tablecenter.getResDeck().AckEmpty){</b>
&nbsp;                    //both decks are empty: same as case 4
<b class="fc">&nbsp;                    remainingTurns = numPlayers + (numPlayers-curPlayerPosition);</b>
<b class="fc">&nbsp;                    for(int i=0;i&lt;numPlayers;i++){</b>
<b class="fc">&nbsp;                        EndGameTriggered event=new EndGameTriggered(&quot;Zero cards left! Starting endgame process&quot;, players.get(i).getNickname(),clone());</b>
<b class="fc">&nbsp;                        getMVListenerByNickname(players.get(i).getNickname()).addEvent(event);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                break;
&nbsp;            //resource deck is found empty
&nbsp;            case 6:
&nbsp;                //same as case 5 but decks are inverted
<b class="pc">&nbsp;                if( tablecenter.getResDeck().AckEmpty){</b>
&nbsp;                    break;
&nbsp;                }
<b class="fc">&nbsp;                tablecenter.getResDeck().AckEmpty=true;</b>
<b class="pc">&nbsp;                if (tablecenter.getGoldDeck().AckEmpty){</b>
<b class="fc">&nbsp;                    remainingTurns = numPlayers + (numPlayers-curPlayerPosition);</b>
<b class="fc">&nbsp;                    for(int i=0;i&lt;numPlayers;i++){</b>
<b class="fc">&nbsp;                        EndGameTriggered event=new EndGameTriggered(&quot;Zero cards left! Starting endgame process&quot;, players.get(i).getNickname(),clone());</b>
<b class="fc">&nbsp;                        getMVListenerByNickname(players.get(i).getNickname()).addEvent(event);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                break;
&nbsp;
&nbsp;            case 7:
<b class="fc">&nbsp;                isTriggered = true;</b>
<b class="fc">&nbsp;                remainingTurns = 0;</b>
<b class="fc">&nbsp;                for(int i = 0; i &lt; numPlayers; i++){</b>
<b class="fc">&nbsp;                    FinalRankings event = new FinalRankings(players.get(i).getNickname(), null);</b>
<b class="pc">&nbsp;                    if(!players.get(i).isDisconnected){</b>
<b class="fc">&nbsp;                        ModelViewListener listener = getMVListenerByNickname(players.get(i).getNickname());</b>
<b class="pc">&nbsp;                        if(listener != null) listener.addEvent(event);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                break;
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calculates the total points of each player, adding the total points to the points acquired by the player&#39;s objective card
&nbsp;     * two different ways of calculating the points, one for each type of objective card.
&nbsp;     * The first one simply requires to check how many times the player has the required set of resources
&nbsp;     * The second one checks through matrix operations if the players respected a certain card pattern
&nbsp;     */
&nbsp;    public void checkWinner(){
&nbsp;
<b class="fc">&nbsp;        HashMap&lt;String,Integer&gt; rankings= new HashMap&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;        isFinished = true;</b>
&nbsp;
<b class="fc">&nbsp;        int[] punteggi = new int[numPlayers];</b>
&nbsp;
<b class="fc">&nbsp;        for(int i = 0; i &lt; numPlayers; i++) { //inizializzazione array punteggi tutti a 0</b>
<b class="fc">&nbsp;            punteggi[i] = 0;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        for(int i = 0; i &lt; numPlayers; i++){ //ciclo per iterare su ogni player. calcolo punti per ogni player</b>
&nbsp;
<b class="fc">&nbsp;            Integer punti = tablecenter.getScoretrack().getRankings().get(players.get(i).getNickname());</b>
<b class="pc">&nbsp;            if (punti!=null) {</b>
<b class="nc">&nbsp;                punteggi[i] = punti;</b>
&nbsp;            }else{
<b class="fc">&nbsp;                punteggi[i] = 0;</b>
&nbsp;            }
&nbsp;
&nbsp;
<b class="fc">&nbsp;            punteggi[i] += checkObjectivePoints(getTablecenter().getObjCards()[0], i);</b>
<b class="fc">&nbsp;            punteggi[i] += checkObjectivePoints(getTablecenter().getObjCards()[1], i);</b>
<b class="fc">&nbsp;            punteggi[i] += checkObjectivePoints(players.get(i).getObjective(), i);</b>
&nbsp;
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        for(int i = 0; i &lt; numPlayers; i++){</b>
<b class="fc">&nbsp;            rankings.put(players.get(i).getNickname(), punteggi[i]);  //fill the rankings hashmap</b>
&nbsp;        }
&nbsp;
&nbsp;
&nbsp;        //send FinalRankings event to everyone
<b class="fc">&nbsp;        FinalRankings event = new FinalRankings(&quot;every one&quot;, rankings);</b>
&nbsp;
<b class="fc">&nbsp;        for(int i = 0; i &lt; numPlayers; i++){</b>
<b class="pc">&nbsp;            if(!players.get(i).isDisconnected)  getMVListenerByNickname(players.get(i).getNickname()).addEvent(event);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calculates the index of the next player cycling through the players array and sets it to the current player index,
&nbsp;     * increments turnCounter and calls checkWinner method if remainingTurns is 0.
&nbsp;     * If remainingTurns are greater than zero, nextPlayer calls itself with the current player passed by parameter
&nbsp;     * @param PreviousPlayer the instance of the player holding the previous turn
&nbsp;     */
&nbsp;    public void nextPlayer(Player PreviousPlayer){
<b class="pc">&nbsp;        if(isFinished){</b>
&nbsp;            return;
&nbsp;        }
&nbsp;        //find next player index
&nbsp;        int nextPlayerIndex;
<b class="pc">&nbsp;        for(nextPlayerIndex = 0; nextPlayerIndex&lt; numPlayers; nextPlayerIndex++){</b>
<b class="fc">&nbsp;            if(players.get(nextPlayerIndex) == PreviousPlayer){break;}</b>
&nbsp;        }
<b class="fc">&nbsp;        if(nextPlayerIndex == numPlayers-1){ nextPlayerIndex = 0;}</b>
<b class="fc">&nbsp;        else{nextPlayerIndex++;}</b>
&nbsp;
<b class="fc">&nbsp;        curPlayerPosition = nextPlayerIndex;</b>
&nbsp;
&nbsp;        //if player isn&#39;t disconnected
<b class="pc">&nbsp;        if(!players.get(curPlayerPosition).isDisconnected) {</b>
&nbsp;            //turn is starting
<b class="fc">&nbsp;            turnPhase=0;</b>
&nbsp;
&nbsp;            //send StartTurn event
<b class="fc">&nbsp;            StartTurn startTurn = new StartTurn(getCurrentPlayerNickname(), players.get(curPlayerPosition).getToken().getColor().toString(), clone());</b>
<b class="fc">&nbsp;            for(ModelViewListener modelViewListener : mvListeners) modelViewListener.addEvent(startTurn);</b>
&nbsp;
&nbsp;            // send play card request event
<b class="fc">&nbsp;            PlayCardRequest playCard = new PlayCardRequest(getCurrentPlayerNickname(),clone());</b>
<b class="pc">&nbsp;            if(!players.get(curPlayerPosition).isDisconnected) getMVListenerByNickname(players.get(curPlayerPosition).getNickname()).addEvent(playCard);</b>
&nbsp;
&nbsp;            //check there are still card on table center
<b class="fc">&nbsp;            boolean empty = true;</b>
<b class="pc">&nbsp;            for (int i = 0; i &lt; 4; i++) {</b>
<b class="pc">&nbsp;                if (tablecenter.getCenterCards()[i] != null) {</b>
<b class="fc">&nbsp;                    empty = false;</b>
&nbsp;                    break;
&nbsp;                }
&nbsp;            }
&nbsp;            //if both deck are not empty and !empty, a draw will be requested
<b class="pc">&nbsp;            if (!tablecenter.getResDeck().AckEmpty || !tablecenter.getGoldDeck().AckEmpty || !empty) {</b>
<b class="fc">&nbsp;                DrawCardRequest drawCard = new DrawCardRequest(players.get(curPlayerPosition).getNickname(), clone(), tablecenter.getResDeck().getNCards(), tablecenter.getGoldDeck().getNCards());</b>
<b class="pc">&nbsp;                if(!players.get(curPlayerPosition).isDisconnected) getMVListenerByNickname(players.get(curPlayerPosition).getNickname()).addEvent(drawCard);</b>
&nbsp;            }
<b class="fc">&nbsp;            turnCounter++;</b>
<b class="fc">&nbsp;            remainingTurns--;</b>
&nbsp;            //if (remainingTurns==0 ) checkWinner();
&nbsp;        }
&nbsp;        else{
<b class="nc">&nbsp;            turnCounter++;</b>
<b class="nc">&nbsp;            remainingTurns--;</b>
<b class="nc">&nbsp;            if (remainingTurns==0 ) checkWinner();</b>
<b class="nc">&nbsp;            else nextPlayer(players.get(curPlayerPosition));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static Card[][] getSubmatrix(Card[][] matrix, int row, int col) { //find 4x4 submatrixs in a NxN matrix
<b class="fc">&nbsp;        Card[][] submatrix = new Card[4][4];</b>
<b class="fc">&nbsp;        for (int i = row, x = 0; i &lt; row + 4; i++, x++) {</b>
<b class="fc">&nbsp;            for (int j = col, y = 0; j &lt; col + 4; j++, y++) {</b>
<b class="fc">&nbsp;                submatrix[x][y] = matrix[i][j];</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return submatrix;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calculates the points totalized by the constraint set by the objective card.
&nbsp;     * The method separates between the two types of Objective Card, analyzing the player&#39;s grid and resources
&nbsp;     * In order to see if the player has achieved what the objective card is requesting.
&nbsp;     * @param objectiveCard the card used to see if the player achieved it&#39;s objective
&nbsp;     * @param playerPos the player position used to retrieve the player and analyze its grid
&nbsp;     * @return points received by the objective card
&nbsp;     */
&nbsp;    int checkObjectivePoints(ObjectiveCard objectiveCard, int playerPos) {
&nbsp;
&nbsp;        // credo sia al contrario
<b class="fc">&nbsp;        if (objectiveCard instanceof ObjectiveCard2) {</b>
<b class="fc">&nbsp;            int minPoints = 1000;</b>
&nbsp;            //calcolo punti a seconda del tipo di obj card
<b class="fc">&nbsp;            for (Resource resource : ((ObjectiveCard2) objectiveCard).getReqMap().keySet()) {</b>
&nbsp;                //controllo le risorse necessarie per i punti
<b class="fc">&nbsp;                int required = ((ObjectiveCard2) objectiveCard).getReqMap().get(resource);</b>
&nbsp;                //basically I check for each resource in the currentresources how many times it has for the card requirements
&nbsp;                //and by taking the minimum of each resource I am sure to take the maximum number of points that the player
&nbsp;                //will have scored
&nbsp;
<b class="pc">&nbsp;                if (required != 0 &amp;&amp; players.get(playerPos).getCurrentResources().currentResources!=null) {</b>
<b class="fc">&nbsp;                    if ((players.get(playerPos).getCurrentResources().currentResources.get(resource) / required) &lt; minPoints) {</b>
<b class="fc">&nbsp;                        minPoints = players.get(playerPos).getCurrentResources().currentResources.get(resource) / required;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;
&nbsp;            }
<b class="fc">&nbsp;            return minPoints*objectiveCard.getPoints(); //aggiungo il punteggio all&#39;array posizionalmente</b>
&nbsp;
&nbsp;
&nbsp;        } else {// ObjectiveCard1
&nbsp;            //We need to scan the entire 81x81 player matrix into 4x4 submatrices and if I find the indicated pattern
&nbsp;            //then I set a found attribute on the card to 1. IF the found attribute is 1 on the found cards (one is enough)
&nbsp;            //then the points WILL NOT BE VALID!!! 0 points.
&nbsp;
<b class="fc">&nbsp;            int totalpoints = 0;</b>
<b class="fc">&nbsp;            int rows = 81;</b>
<b class="fc">&nbsp;            int columns = 81;</b>
<b class="fc">&nbsp;            Card[] savedCards = new Card[3];</b>
<b class="fc">&nbsp;            for (int k = 0; k &lt; rows - 3; k++) {</b>
<b class="fc">&nbsp;                for (int j = 0; j &lt; columns - 3; j++) {</b>
&nbsp;                    //get the 3x3 submatrix needed to perform operations on (checking obj cards requisites)
<b class="fc">&nbsp;                    Card[][] subMatrix = getSubmatrix(players.get(playerPos).getHand().getDisplayedCards(), k, j);</b>
<b class="fc">&nbsp;                    boolean found = true;</b>
&nbsp;
<b class="fc">&nbsp;                    int counter = 0;</b>
&nbsp;                    //for each 4x4 matrix I do:
<b class="pc">&nbsp;                        for (int index = 0; index &lt; 3; index++) { //quindi 3 iterazioni (per le 3 carte)</b>
<b class="fc">&nbsp;                            int x = 0; //ROWS</b>
<b class="fc">&nbsp;                            int y = 0; //COLUMNS</b>
&nbsp;                            //switch case to translate position into matrix position[][]
<b class="pc">&nbsp;                            switch (((ObjectiveCard1) objectiveCard).getRequiredPositions()[index]) {</b>
&nbsp;                                case 1: //posizioni partono da 1
<b class="fc">&nbsp;                                    x = 0;</b>
<b class="fc">&nbsp;                                    y = 0;</b>
&nbsp;                                    break;
&nbsp;                                case 2:
<b class="nc">&nbsp;                                    x = 0;</b>
<b class="nc">&nbsp;                                    y = 1;</b>
&nbsp;                                    break;
&nbsp;                                case 3:
<b class="fc">&nbsp;                                    x = 0;</b>
<b class="fc">&nbsp;                                    y = 2;</b>
&nbsp;                                    break;
&nbsp;                                case 4:
<b class="nc">&nbsp;                                    x = 0;</b>
<b class="nc">&nbsp;                                    y = 3;</b>
&nbsp;                                    break;
&nbsp;                                case 5:
<b class="nc">&nbsp;                                    x = 1;</b>
<b class="nc">&nbsp;                                    y = 0;</b>
&nbsp;                                    break;
&nbsp;                                case 6:
<b class="nc">&nbsp;                                    x = 1;</b>
<b class="nc">&nbsp;                                    y = 1;</b>
&nbsp;                                    break;
&nbsp;                                case 7:
<b class="nc">&nbsp;                                    x = 1;</b>
<b class="nc">&nbsp;                                    y = 2;</b>
&nbsp;                                    break;
&nbsp;                                case 8:
<b class="nc">&nbsp;                                    x = 1;</b>
<b class="nc">&nbsp;                                    y = 3;</b>
&nbsp;                                    break;
&nbsp;                                case 9:
<b class="nc">&nbsp;                                    x = 2;</b>
<b class="nc">&nbsp;                                    y = 0;</b>
&nbsp;                                    break;
&nbsp;                                case 10:
<b class="nc">&nbsp;                                    x = 2;</b>
<b class="nc">&nbsp;                                    y = 1;</b>
&nbsp;                                    break;
&nbsp;                                case 11:
<b class="nc">&nbsp;                                    x = 2;</b>
<b class="nc">&nbsp;                                    y = 2;</b>
&nbsp;                                    break;
&nbsp;                                case 12:
<b class="nc">&nbsp;                                    x = 2;</b>
<b class="nc">&nbsp;                                    y = 3;</b>
&nbsp;                                    break;
&nbsp;                                case 13:
<b class="nc">&nbsp;                                    x = 3;</b>
<b class="nc">&nbsp;                                    y = 0;</b>
&nbsp;                                    break;
&nbsp;                                case 14:
<b class="nc">&nbsp;                                    x = 3;</b>
<b class="nc">&nbsp;                                    y = 1;</b>
&nbsp;                                    break;
&nbsp;                                case 15:
<b class="nc">&nbsp;                                    x = 3;</b>
<b class="nc">&nbsp;                                    y = 2;</b>
&nbsp;                                    break;
&nbsp;                                case 16:
<b class="nc">&nbsp;                                    x = 3;</b>
<b class="nc">&nbsp;                                    y = 3;</b>
&nbsp;                                    break;
&nbsp;                            }
&nbsp;
<b class="pc">&nbsp;                            if (subMatrix[x][y] == null || subMatrix[x][y] instanceof StartingCard || ((PlayableCard)subMatrix[x][y]).isChecked == 1) {</b>
<b class="fc">&nbsp;                                found = false;</b>
&nbsp;                                break;
&nbsp;                            }
&nbsp;
<b class="pc">&nbsp;                            if (subMatrix[x][y] != null) {</b>
<b class="pc">&nbsp;                                if (subMatrix[x][y].getColor() == ((ObjectiveCard1) objectiveCard).getCardColors()[index]) { //if the color matches that of the required in that position</b>
<b class="nc">&nbsp;                                    savedCards[index] = subMatrix[x][y];</b>
<b class="nc">&nbsp;                                    counter++;</b>
&nbsp;
&nbsp;                                } else {
<b class="fc">&nbsp;                                    found = false;</b>
&nbsp;                                    break;
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;
&nbsp;                        }
<b class="pc">&nbsp;                        if(found &amp;&amp; counter == 3){</b>
<b class="nc">&nbsp;                            for(int z = 0; z &lt; 3; z++){</b>
<b class="nc">&nbsp;                                ((PlayableCard)savedCards[z]).isChecked = 1;</b>
&nbsp;
&nbsp;                            }
<b class="nc">&nbsp;                            totalpoints += objectiveCard.points;</b>
&nbsp;
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;            for(int rowz = 0; rowz &lt; 81; rowz++){ //serve per resettare i checked a fine partita</b>
<b class="fc">&nbsp;                for(int columnz = 0; columnz &lt; 81; columnz++){</b>
<b class="pc">&nbsp;                    if (!(players.get(playerPos).getHand().getDisplayedCards()[rowz][columnz] instanceof StartingCard) &amp;&amp;</b>
<b class="fc">&nbsp;                            players.get(playerPos).getHand().getDisplayedCards()[rowz][columnz]!= null ) {</b>
<b class="fc">&nbsp;                        ((PlayableCard) players.get(playerPos).getHand().getDisplayedCards()[rowz][columnz]).isChecked = 0;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            return totalpoints;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method to clone the game.
&nbsp;     * @return the game cloned.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public GameView clone(){
<b class="fc">&nbsp;        return new GameView(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The One Player Left procedure is called when it is noted that there&#39;s only one active player.
&nbsp;     */
&nbsp;    private synchronized void OPLProcedure(boolean wait){
<b class="nc">&nbsp;        if(wait){</b>
&nbsp;            try{
&nbsp;                // Wait for some seconds.
<b class="nc">&nbsp;                synchronized (OPLLock){</b>
<b class="nc">&nbsp;                    OPLLock.wait(timeoutOnePlayer*1000);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }catch(InterruptedException e){</b>
<b class="nc">&nbsp;                e.printStackTrace();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if(getActivePlayers() &gt; 1){</b>
<b class="nc">&nbsp;            synchronized (mvListeners){</b>
<b class="nc">&nbsp;                for(int i = 0; i &lt; mvListeners.size(); i++){</b>
<b class="nc">&nbsp;                    mvListeners.get(i).addEvent(new ServerMessage(&quot;The game is resuming...&quot;, &quot;every one&quot;));</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;        else{
<b class="nc">&nbsp;            if     (getActivePlayers() == 1) System.out.println(&quot;[END] Game ended: only one player left.&quot;);</b>
<b class="nc">&nbsp;            else if(getActivePlayers() == 0)</b>
<b class="nc">&nbsp;                System.out.println(&quot;[END] Game ended: no players left.&quot;);</b>
&nbsp;
<b class="nc">&nbsp;            endGame(7);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method to disconnect a player from the game.
&nbsp;     * @param player the disconnected player
&nbsp;     */
&nbsp;    public void disconnectPlayer(Player player){
&nbsp;
<b class="fc">&nbsp;        if(!isStarted){</b>
<b class="fc">&nbsp;            players.remove(player);</b>
<b class="fc">&nbsp;            numPlayers--;</b>
<b class="pc">&nbsp;            if(numPlayers &lt;= 1) OPLProcedure(false);</b>
&nbsp;        }
<b class="fc">&nbsp;        else player.isDisconnected = true;</b>
&nbsp;
&nbsp;        // Send a notification to every active player.
<b class="fc">&nbsp;        synchronized (mvListeners){</b>
<b class="fc">&nbsp;            for(Player p : players){</b>
<b class="pc">&nbsp;                if(!p.isDisconnected){</b>
<b class="pc">&nbsp;                    PlayerDisconnected event = new PlayerDisconnected(&quot;every one&quot;, player != null ? player.getNickname() : &quot;A client&quot;, getActivePlayers(), false);</b>
<b class="fc">&nbsp;                    getMVListenerByNickname(p.getNickname()).addEvent(event);</b>
&nbsp;                };
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        if(!isStarted) return;</b>
&nbsp;
&nbsp;        // If it&#39;s the disconnected player&#39;s turn, simply skips it and go to the next player.
<b class="pc">&nbsp;        if(getCurrentPlayerNickname().equals(player.getNickname())){</b>
<b class="nc">&nbsp;            if(turnPhase == 0){</b>
&nbsp;                // Skips the turn.
&nbsp;            }
<b class="nc">&nbsp;            else if(turnPhase == 1){</b>
<b class="nc">&nbsp;                PlayableCard newCard = null;</b>
&nbsp;
&nbsp;                // Draws the first card on the table.
<b class="nc">&nbsp;                for(PlayableCard card : tablecenter.getCenterCards()){</b>
<b class="nc">&nbsp;                    if(card!=null){newCard = card;</b>
&nbsp;                    break;}
&nbsp;                }
&nbsp;
&nbsp;                try{
<b class="nc">&nbsp;                    player.getHand().DrawPositionedCard(newCard);</b>
<b class="nc">&nbsp;                }catch (HandFullException | isEmptyException ignored){}</b>
&nbsp;            }
<b class="nc">&nbsp;            else if(turnPhase == 2){</b>
&nbsp;                // Skips the turn.
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if(getCurrentPlayerNickname() != null){</b>
<b class="nc">&nbsp;                for(ModelViewListener listener : mvListeners){</b>
<b class="nc">&nbsp;                    listener.addEvent(new EndTurn(getCurrentPlayerNickname(), listener.nickname, clone()));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            isTurnSkipped = true;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method that returns the number of currently active players. Notice that it is equivalent to the
&nbsp;     * number of listeners in their list.
&nbsp;     * @return
&nbsp;     */
&nbsp;    private int getActivePlayers(){
<b class="fc">&nbsp;        return mvListeners.size();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method to stop the running threads.
&nbsp;     */
&nbsp;    public void stop(){
<b class="nc">&nbsp;        running = false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method to rejoin the game after a disconnection.
&nbsp;     * @param newListener the listener associated to the rejoined player.
&nbsp;     */
&nbsp;    public synchronized void rejoin(ModelViewListener newListener) {
<b class="fc">&nbsp;        int pos = -1;</b>
&nbsp;
&nbsp;        // Notify the rejoined player about the current situation.
<b class="fc">&nbsp;        newListener.addEvent(new TurnOrder(newListener.nickname, turnOrder, this.clone()));</b>
&nbsp;
&nbsp;        // Notify the other players about the rejoining.
<b class="fc">&nbsp;        for (int i = 0; i &lt; players.size(); i++) {</b>
<b class="fc">&nbsp;            if(players.get(i).getNickname().equals(newListener.nickname)) pos = i;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        players.get(pos).isDisconnected = false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Getter for the listener associated with the nickname.
&nbsp;     * @param nickname
&nbsp;     * @return the listener if found, else null.
&nbsp;     */
&nbsp;    private ModelViewListener getMVListenerByNickname(String nickname){
<b class="pc">&nbsp;        for(ModelViewListener listener : mvListeners){</b>
<b class="fc">&nbsp;            if(listener.nickname.equals(nickname)){</b>
<b class="fc">&nbsp;                return listener;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Setter for the listeners&#39; list.
&nbsp;     * @param mvListeners the list of model-view listeners
&nbsp;     */
&nbsp;    public void setMVListeners(ArrayList&lt;ModelViewListener&gt; mvListeners) {
<b class="fc">&nbsp;        this.mvListeners = mvListeners;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Getter for the listeners&#39; list.
&nbsp;     * @return the listeners&#39; list.
&nbsp;     */
&nbsp;    public ArrayList&lt;ModelViewListener&gt; getMvListeners() {
<b class="fc">&nbsp;        return mvListeners;</b>
&nbsp;    }
&nbsp;}
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-07-03 15:07</div>
</div>
</body>
</html>
